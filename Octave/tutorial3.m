%곱셈

>> A = [1 2; 3 4; 5 6]
A =

   1   2
   3   4
   5   6

>> B = [11 12; 13 14; 15 16]
B =

   11   12
   13   14
   15   16

>> C = [1 1; 2 2]
C =

   1   1
   2   2


>> A*C   %흔히 생각하는 행렬간 곱셈
ans =

    5    5
   11   11
   17   17


>> A.*B  %행렬의 각 (행,열) 값끼리의 곱
ans =

   11   24
   39   56
   75   96

>> A .^2  %행렬의 각(행,열)에 ^2를 함 
    1    4
    9   16
   25   36
   
>> v = [1;2;3]
v =

   1
   2
   3
      
>> 1 ./ v   *1나누기 행렬 (1/n 꼴)
ans =

   1.00000
   0.50000
   0.33333

>> log(v)
ans =

   0.00000
   0.69315
   1.09861

>> exp(v)
ans =

    2.7183
    7.3891
   20.0855

>> abs([-1;-2;-3])  %절대값
ans =

   1
   2
   3

>> -v  % == (-1)*v
ans =

  -1
  -2
  -3
  
>> v + ones(length(v),1)  %(1;2;3) + (1;1;1)
ans =

   2
   3
   4

>> A'  %A 전치행렬(Transpose)
ans =

   1   3   5
   2   4   6
   
>> A''      %전치행렬의 전치행렬(원행렬로 돌아옴) 
ans =

   1   2
   3   4
   5   6

>> (A')'
ans =

   1   2
   3   4
   5   6

>> a = [1 15 2 0.5]
a =

    1.00000   15.00000    2.00000    0.50000

>> val = max(a)   %값들 중 가장 큰 값
val =  15
   
>> B = [1 6; 5 2; 4 3] %행렬에서 max를 쓰면, 열 단위로 최대값을 찾아서 출력
B =

   1   6
   5   2
   4   3

>> max(B)
ans =

   5   6


a = 1.00000   15.00000    2.00000    0.50000
>> a<3  %3보다 작으면 참(1), 크거나 같으면 거짓(0)
ans =

  1  0  1  1

>> find(a<3)   %조건에 맞는 n번째 값들을 순서(값 아님)로 출력한다. 
ans =

   1   3   4

>> A = magic(3)   %마방진을 만들어줌(n*n 행렬, 가로/세로/대각의 합이 같음)
A =

   8   1   6
   3   5   7
   4   9   2

>> [r,c] = find(A>=7)  (r = 행, c = 열 을 찾아줌)
r =

   1
   3
   2

c =

   1
   2
   3

>> a
a =

    1.00000   15.00000    2.00000    0.50000

>> sum(a)
ans =  18.500
>> prod(a)
ans =  15
>> floor(a) %반올림
ans =

    1   15    2    0

>> ceil(a)  %올림
ans =

    1   15    2    1
   
>> max(rand(3), rand(3)) %랜덤한 3*3 행렬에서 원소단위의 최대값 반환
ans =

   0.96629   0.84596   0.86952
   0.69671   0.37143   0.44771
   0.98440   0.18956   0.32513

>> A
A =

   8   1   6
   3   5   7
   4   9   2

>> max(A, [], 1) %각 열간 최대값 
ans =

   8   9   7

>> max(A, [], 2) %각 행별 최대값
ans =

   8
   7
   9

>> A(:)  %벡터값으로 변환
ans =

   8
   3
   4
   1
   5
   9
   6
   7
   2

>> max(A)
ans =

   8   9   7
   
>> A = magic(9)
A =

   47   58   69   80    1   12   23   34   45
   57   68   79    9   11   22   33   44   46
   67   78    8   10   21   32   43   54   56
   77    7   18   20   31   42   53   55   66
    6   17   19   30   41   52   63   65   76
   16   27   29   40   51   62   64   75    5
   26   28   39   50   61   72   74    4   15
   36   38   49   60   71   73    3   14   25
   37   48   59   70   81    2   13   24   35

>> sum(A,1)  %각 열의 합
ans =

   369   369   369   369   369   369   369   369   369
   
>> sum(A,2)  %각 행의 합
ans =

   369
   369
   369
   369
   369
   369
   369
   369
   369

>> eye(9)
ans =

Diagonal Matrix

   1   0   0   0   0   0   0   0   0
   0   1   0   0   0   0   0   0   0
   0   0   1   0   0   0   0   0   0
   0   0   0   1   0   0   0   0   0
   0   0   0   0   1   0   0   0   0
   0   0   0   0   0   1   0   0   0
   0   0   0   0   0   0   1   0   0
   0   0   0   0   0   0   0   1   0
   0   0   0   0   0   0   0   0   1

>> A .* eye(9)
ans =

   47    0    0    0    0    0    0    0    0
    0   68    0    0    0    0    0    0    0
    0    0    8    0    0    0    0    0    0
    0    0    0   20    0    0    0    0    0
    0    0    0    0   41    0    0    0    0
    0    0    0    0    0   62    0    0    0
    0    0    0    0    0    0   74    0    0
    0    0    0    0    0    0    0   14    0
    0    0    0    0    0    0    0    0   35

>> sum(A.*eye(9))
ans =

   47   68    8   20   41   62   74   14   35

>> sum(sum(A.*eye(9)))
ans =  369

>> sum(sum(A.*flipud(eye(9))))  %flipud(filp updown)으로 말그대로 뒤집을 수 있음 
ans =  369

>> pinv(A) %역행렬 


